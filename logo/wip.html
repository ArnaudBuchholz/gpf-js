<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>GPF-JS logo</title>
    <script language="JavaScript">
        var gpfSourcesPath = "../src/";
    </script>
    <script language="JavaScript" src="../src/boot.js"></script>
    <script language="JavaScript">

function onLoad() {
    var svg = document.getElementById("svg"),
        path = gpf.web.createTagFunction("svg:path");

    // Background grid
    var WIDTH = 14,
        HEIGHT = 9,
        grid = new Array(WIDTH * HEIGHT);
    [
        [8],
        [3,5,7,0,9,11],
        [2,12],
        [2,12],
        [2,11,13],
        [0,0,3,10,13],
        [2,10,12],
        [2,10],
        [4,0,8]
    ].forEach(function (row, y) {
        var idx = 0;
        while (idx < row.length) {
            var fromX = row[idx++],
                x = row[idx++] || fromX;
            while (x >= fromX) {
                grid[y * WIDTH + x--] = true;
            }
        }
    });

    function tile (x, y) {
        return path({
            fill: "none",
            stroke: "black",
            "stroke-width": .1,
            d: ["M", x, y, "L", x + 1, y - 1, "L", x + 2, y - 1, "L", x + 3, y,
                "L", x + 2, y + 1, "L", x + 1, y + 1, "L", x, y].join(" ")
        })
    }

    var borders = [];

    function addBorder(mx, my, lx, ly) {
        borders.push({mx: mx, my: my, lx: lx, ly: ly});
    }

    for (y = 0; y < HEIGHT; ++y) {
        for (x = 0; x < WIDTH; ++x) {
            if (grid[y * WIDTH + x]) {
                var x0 = 1 + x * 2,
                    y0 = 2 + y * 2 + x % 2,
                    yUp,
                    yDown;
                if (x % 2) {
                    yUp = y;
                    yDown = y + 1;
                } else {
                    yUp = y - 1;
                    yDown = y;
                }
                tile(x0, y0).appendTo(svg);
                if (0 === y || !grid[(y - 1) * WIDTH + x]) {
                    addBorder(x0 + 1, y0 - 1, x0 + 2, y0 - 1);
                }
                if (0 === x) {
                    addBorder(x0, y0, x0 + 1, y0 - 1);
                    addBorder(x0 + 1, y0 + 1, x0, y0);
                } else {
                    if (-1 === yUp || !grid[yUp * WIDTH + x - 1]) {
                        addBorder(x0, y0, x0 + 1, y0 - 1);
                    }
                    if (HEIGHT > y && !grid[yDown * WIDTH + x - 1]) {
                        addBorder(x0 + 1, y0 + 1, x0, y0);
                    }
                }
                if (WIDTH - 1 === x) {
                    addBorder(x0 + 2, y0 - 1, x0 + 3, y0);
                    addBorder(x0 + 3, y0, x0 + 2, y0 + 1);
                } else {
                    if (-1 === yUp || !grid[yUp * WIDTH + x + 1]) {
                        addBorder(x0 + 2, y0 - 1, x0 + 3, y0);
                    }
                    if (HEIGHT > y && !grid[yDown * WIDTH + x + 1]) {
                        addBorder(x0 + 3, y0, x0 + 2, y0 + 1);
                    }
                }
                if (HEIGHT - 1 === y || !grid[(y + 1) * WIDTH + x]) {
                    addBorder(x0 + 2, y0 + 1, x0 + 1, y0 + 1);
                }
            }
        }
    }

    path({
        fill: "none",
        stroke: "red",
        "stroke-width": .2,
        d: borders.map(function (vector) {
            return "M " + vector.mx + " " + vector.my + " L " + vector.lx + " " + vector.ly;
        }).join(" ")
    }).appendTo(svg);

    function ref (_refX, _refY) {
        var _d = [];
        function _at(x, y) {
            if (0 === _refX % 2 && x % 2) {
                --y;
            }
            var absX = _refX + x,
                svgX = 2.5 + 2 * absX,
                svgY = 2 + 2 * (_refY + y) + absX % 2;
            return svgX + " " + svgY;
        }
        return {
            m: function (x, y) {
                _d.push("M", _at(x, y));
                return this;
            },

            l: function (x, y) {
                _d.push("L", _at(x, y));
                return this;
            },

            toString: function () {
                return _d.join(" ");
            }
        };
    }

    function letter(d) {
        return path({
            fill: "none",
            stroke: "red",
            "stroke-width": 1,
            d: d.toString()
        });
    }

    function g (x, y) {
        return ref(x, y).m(0, 0).l(1, 1).l(2, 0).l(2, -4).l(1, -4).l(0, -4).l(0, -3).l(1, -2);
    }

    function p (x, y) {
        return ref(x, y).m(0, 0).l(0, -3).l(1, -3).l(2, -3).l(2, -2).l(1, -1);
    }

    function f (x, y) {
        return ref(x, y).m(0, 0).l(1, 1).l(2, 0).l(2, -4).l(3, -4).l(4, -4).m(1, -1).l(3, -2);
    }

    letter(g(3, 6)).appendTo(svg);
    letter(p(6, 6)).appendTo(svg);
    letter(f(7, 6)).appendTo(svg);

}

    </script>
</head>
<body onload="onLoad()">
    <svg id="svg" width="100%" height="50%" viewBox="0 0 40 20">
    </svg>
</body>
</html>
